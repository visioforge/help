---
title: H.264 Encoder Interface Reference
description: H.264/AVC encoder DirectShow interface with bitrate control, profile/level configuration, GOP settings, and rate control parameters.
---

# H.264 Encoder Interface Reference

## Overview

The **IH264Encoder** interface provides comprehensive control over H.264/AVC (Advanced Video Coding) video encoding in DirectShow filter graphs. H.264 is the industry-standard video compression format used for broadcast, streaming, and distribution applications.

This interface allows developers to configure encoding profiles, bitrate control, Group of Pictures (GOP) structure, macroblock encoding modes, and advanced timing parameters for optimal video quality and file size in various scenarios including streaming, broadcast, and archival.

**Interface GUID**: `{09FA2EA3-4773-41a8-90DC-9499D4061E9F}`

**Inherits From**: `IUnknown`

## Interface Definitions

### C# Definition

```csharp
using System;
using System.Runtime.InteropServices;

namespace VisioForge.DirectShowAPI
{
    /// <summary>
    /// H.264/AVC (Advanced Video Coding) encoder configuration interface.
    /// Provides comprehensive control over H.264 encoding parameters including
    /// bitrate control, profile/level settings, GOP structure, and rate control modes.
    /// </summary>
    [ComImport]
    [Guid("09FA2EA3-4773-41a8-90DC-9499D4061E9F")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IH264Encoder
    {
        /// <summary>
        /// Gets the target bitrate for encoding.
        /// </summary>
        /// <param name="plValue">Receives the bitrate in bits per second (bps)</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int get_Bitrate([Out] out int plValue);

        /// <summary>
        /// Sets the target bitrate for encoding.
        /// </summary>
        /// <param name="lValue">Bitrate in bits per second (bps). Typical range: 500,000 to 50,000,000</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int put_Bitrate([In] int lValue);

        /// <summary>
        /// Gets the rate control mode.
        /// </summary>
        /// <param name="pValue">Receives the rate control mode (0=CBR, 1=VBR)</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int get_RateControl([Out] out int pValue);

        /// <summary>
        /// Sets the rate control mode.
        /// </summary>
        /// <param name="value">Rate control mode: 0 = CBR (Constant Bitrate), 1 = VBR (Variable Bitrate)</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int put_RateControl([In] int value);

        /// <summary>
        /// Gets the macroblock encoding mode.
        /// </summary>
        /// <param name="pValue">Receives the MB encoding mode</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int get_MbEncoding([Out] out int pValue);

        /// <summary>
        /// Sets the macroblock encoding mode (affects encoding complexity and quality).
        /// </summary>
        /// <param name="value">MB encoding mode value</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int put_MbEncoding([In] int value);

        /// <summary>
        /// Gets the GOP (Group of Pictures) enable state.
        /// </summary>
        /// <param name="pValue">Receives true if GOP is enabled, false otherwise</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int get_GOP([Out] [MarshalAs(UnmanagedType.Bool)] out bool pValue);

        /// <summary>
        /// Enables or disables GOP (Group of Pictures) structure.
        /// </summary>
        /// <param name="value">True to enable GOP, false to disable (all I-frames)</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int put_GOP([In] [MarshalAs(UnmanagedType.Bool)] bool value);

        /// <summary>
        /// Gets the auto-bitrate adjustment state.
        /// </summary>
        /// <param name="pValue">Receives true if auto-bitrate is enabled, false otherwise</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int get_AutoBitrate([Out] [MarshalAs(UnmanagedType.Bool)] out bool pValue);

        /// <summary>
        /// Enables or disables automatic bitrate adjustment.
        /// When enabled, the encoder automatically adjusts bitrate based on content complexity.
        /// </summary>
        /// <param name="value">True to enable auto-bitrate, false for fixed bitrate</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int put_AutoBitrate([In] [MarshalAs(UnmanagedType.Bool)] bool value);

        /// <summary>
        /// Gets the H.264 profile.
        /// </summary>
        /// <param name="pValue">Receives the profile value</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int get_Profile([Out] out int pValue);

        /// <summary>
        /// Sets the H.264 profile (Baseline, Main, High, etc.).
        /// </summary>
        /// <param name="value">Profile value: 66=Baseline, 77=Main, 100=High</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int put_Profile([In] int value);

        /// <summary>
        /// Gets the H.264 level.
        /// </summary>
        /// <param name="pValue">Receives the level value</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int get_Level([Out] out int pValue);

        /// <summary>
        /// Sets the H.264 level (constrains resolution, bitrate, and frame rate).
        /// </summary>
        /// <param name="value">Level value: 10=Level 1.0, 11=Level 1.1, ..., 51=Level 5.1</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int put_Level([In] int value);

        /// <summary>
        /// Gets the usage mode (quality/speed trade-off).
        /// </summary>
        /// <param name="pValue">Receives the usage mode value</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int get_Usage([Out] out int pValue);

        /// <summary>
        /// Sets the usage mode to optimize for quality vs. speed.
        /// </summary>
        /// <param name="value">Usage mode: 0=Quality, 1=Balanced, 2=Speed</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int put_Usage([In] int value);

        /// <summary>
        /// Gets the sequential timing mode.
        /// </summary>
        /// <param name="pValue">Receives the sequential timing value</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int get_SequentialTiming([Out] out int pValue);

        /// <summary>
        /// Sets the sequential timing mode for frame processing.
        /// </summary>
        /// <param name="value">Sequential timing mode value</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int put_SequentialTiming([In] int value);

        /// <summary>
        /// Gets the slice intervals for IDR and P frames.
        /// </summary>
        /// <param name="piIDR">Receives the IDR frame interval</param>
        /// <param name="piP">Receives the P frame interval</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int get_SliceIntervals([Out] out int piIDR, [Out] out int piP);

        /// <summary>
        /// Sets the slice intervals for IDR (Instantaneous Decoder Refresh) and P frames.
        /// IDR frames are full keyframes, P frames are predicted frames.
        /// </summary>
        /// <param name="piIDR">IDR frame interval (every N frames). Typical: 30-300</param>
        /// <param name="piP">P frame interval. Typical: 1-3</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int put_SliceIntervals([In] ref int piIDR, [In] ref int piP);

        /// <summary>
        /// Gets the maximum bitrate for VBR encoding.
        /// </summary>
        /// <param name="plValue">Receives the maximum bitrate in bps</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int get_MaxBitrate([Out] out int plValue);

        /// <summary>
        /// Sets the maximum bitrate for Variable Bitrate (VBR) encoding.
        /// Only applicable when rate control is set to VBR.
        /// </summary>
        /// <param name="lValue">Maximum bitrate in bits per second (bps)</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int put_MaxBitrate([In] int lValue);

        /// <summary>
        /// Gets the minimum bitrate for VBR encoding.
        /// </summary>
        /// <param name="plValue">Receives the minimum bitrate in bps</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int get_MinBitrate([Out] out int plValue);

        /// <summary>
        /// Sets the minimum bitrate for Variable Bitrate (VBR) encoding.
        /// Only applicable when rate control is set to VBR.
        /// </summary>
        /// <param name="lValue">Minimum bitrate in bits per second (bps)</param>
        /// <returns>HRESULT (0 for success)</returns>
        [PreserveSig]
        int put_MinBitrate([In] int lValue);
    }
}
```

### C++ Definition

```cpp
#include <unknwn.h>

// {09FA2EA3-4773-41a8-90DC-9499D4061E9F}
DEFINE_GUID(IID_IH264Encoder,
    0x09fa2ea3, 0x4773, 0x41a8, 0x90, 0xdc, 0x94, 0x99, 0xd4, 0x06, 0x1e, 0x9f);

/// <summary>
/// H.264/AVC (Advanced Video Coding) encoder configuration interface.
/// Provides comprehensive control over H.264 encoding parameters.
/// </summary>
DECLARE_INTERFACE_(IH264Encoder, IUnknown)
{
    /// <summary>
    /// Gets the target bitrate for encoding.
    /// </summary>
    /// <param name="plValue">Pointer to receive bitrate in bits per second (bps)</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(get_Bitrate)(THIS_
        long* plValue
        ) PURE;

    /// <summary>
    /// Sets the target bitrate for encoding.
    /// </summary>
    /// <param name="lValue">Bitrate in bits per second (bps)</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(put_Bitrate)(THIS_
        long lValue
        ) PURE;

    /// <summary>
    /// Gets the rate control mode.
    /// </summary>
    /// <param name="pValue">Pointer to receive rate control mode</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(get_RateControl)(THIS_
        int* pValue
        ) PURE;

    /// <summary>
    /// Sets the rate control mode.
    /// </summary>
    /// <param name="value">Rate control mode: 0 = CBR, 1 = VBR</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(put_RateControl)(THIS_
        int value
        ) PURE;

    /// <summary>
    /// Gets the macroblock encoding mode.
    /// </summary>
    /// <param name="pValue">Pointer to receive MB encoding mode</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(get_MbEncoding)(THIS_
        int* pValue
        ) PURE;

    /// <summary>
    /// Sets the macroblock encoding mode.
    /// </summary>
    /// <param name="value">MB encoding mode value</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(put_MbEncoding)(THIS_
        int value
        ) PURE;

    /// <summary>
    /// Gets the GOP enable state.
    /// </summary>
    /// <param name="pValue">Pointer to receive GOP enabled state</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(get_GOP)(THIS_
        BOOL* pValue
        ) PURE;

    /// <summary>
    /// Enables or disables GOP structure.
    /// </summary>
    /// <param name="value">TRUE to enable GOP, FALSE to disable</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(put_GOP)(THIS_
        BOOL value
        ) PURE;

    /// <summary>
    /// Gets the auto-bitrate adjustment state.
    /// </summary>
    /// <param name="pValue">Pointer to receive auto-bitrate state</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(get_AutoBitrate)(THIS_
        BOOL* pValue
        ) PURE;

    /// <summary>
    /// Enables or disables automatic bitrate adjustment.
    /// </summary>
    /// <param name="value">TRUE to enable auto-bitrate, FALSE for fixed</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(put_AutoBitrate)(THIS_
        BOOL value
        ) PURE;

    /// <summary>
    /// Gets the H.264 profile.
    /// </summary>
    /// <param name="pValue">Pointer to receive profile value</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(get_Profile)(THIS_
        int* pValue
        ) PURE;

    /// <summary>
    /// Sets the H.264 profile.
    /// </summary>
    /// <param name="value">Profile value: 66=Baseline, 77=Main, 100=High</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(put_Profile)(THIS_
        int value
        ) PURE;

    /// <summary>
    /// Gets the H.264 level.
    /// </summary>
    /// <param name="pValue">Pointer to receive level value</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(get_Level)(THIS_
        int* pValue
        ) PURE;

    /// <summary>
    /// Sets the H.264 level.
    /// </summary>
    /// <param name="value">Level value: 10-51</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(put_Level)(THIS_
        int value
        ) PURE;

    /// <summary>
    /// Gets the usage mode.
    /// </summary>
    /// <param name="pValue">Pointer to receive usage mode</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(get_Usage)(THIS_
        int* pValue
        ) PURE;

    /// <summary>
    /// Sets the usage mode.
    /// </summary>
    /// <param name="value">Usage mode: 0=Quality, 1=Balanced, 2=Speed</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(put_Usage)(THIS_
        int value
        ) PURE;

    /// <summary>
    /// Gets the sequential timing mode.
    /// </summary>
    /// <param name="pValue">Pointer to receive sequential timing value</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(get_SequentialTiming)(THIS_
        int* pValue
        ) PURE;

    /// <summary>
    /// Sets the sequential timing mode.
    /// </summary>
    /// <param name="value">Sequential timing mode value</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(put_SequentialTiming)(THIS_
        int value
        ) PURE;

    /// <summary>
    /// Gets the slice intervals.
    /// </summary>
    /// <param name="piIDR">Pointer to receive IDR frame interval</param>
    /// <param name="piP">Pointer to receive P frame interval</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(get_SliceIntervals)(THIS_
        int* piIDR,
        int* piP
        ) PURE;

    /// <summary>
    /// Sets the slice intervals.
    /// </summary>
    /// <param name="piIDR">Pointer to IDR frame interval</param>
    /// <param name="piP">Pointer to P frame interval</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(put_SliceIntervals)(THIS_
        int* piIDR,
        int* piP
        ) PURE;

    /// <summary>
    /// Gets the maximum bitrate.
    /// </summary>
    /// <param name="plValue">Pointer to receive maximum bitrate in bps</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(get_MaxBitrate)(THIS_
        long* plValue
        ) PURE;

    /// <summary>
    /// Sets the maximum bitrate for VBR encoding.
    /// </summary>
    /// <param name="lValue">Maximum bitrate in bps</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(put_MaxBitrate)(THIS_
        long lValue
        ) PURE;

    /// <summary>
    /// Gets the minimum bitrate.
    /// </summary>
    /// <param name="plValue">Pointer to receive minimum bitrate in bps</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(get_MinBitrate)(THIS_
        long* plValue
        ) PURE;

    /// <summary>
    /// Sets the minimum bitrate for VBR encoding.
    /// </summary>
    /// <param name="lValue">Minimum bitrate in bps</param>
    /// <returns>S_OK for success</returns>
    STDMETHOD(put_MinBitrate)(THIS_
        long lValue
        ) PURE;
};
```

### Delphi Definition

```delphi
uses
  ActiveX, ComObj;

const
  IID_IH264Encoder: TGUID = '{09FA2EA3-4773-41a8-90DC-9499D4061E9F}';

type
  /// <summary>
  /// H.264/AVC encoder configuration interface.
  /// </summary>
  IH264Encoder = interface(IUnknown)
    ['{09FA2EA3-4773-41a8-90DC-9499D4061E9F}']

    /// <summary>
    /// Gets the target bitrate for encoding.
    /// </summary>
    function get_Bitrate(out plValue: Integer): HRESULT; stdcall;

    /// <summary>
    /// Sets the target bitrate for encoding.
    /// </summary>
    function put_Bitrate(lValue: Integer): HRESULT; stdcall;

    /// <summary>
    /// Gets the rate control mode.
    /// </summary>
    function get_RateControl(out pValue: Integer): HRESULT; stdcall;

    /// <summary>
    /// Sets the rate control mode (0=CBR, 1=VBR).
    /// </summary>
    function put_RateControl(value: Integer): HRESULT; stdcall;

    /// <summary>
    /// Gets the macroblock encoding mode.
    /// </summary>
    function get_MbEncoding(out pValue: Integer): HRESULT; stdcall;

    /// <summary>
    /// Sets the macroblock encoding mode.
    /// </summary>
    function put_MbEncoding(value: Integer): HRESULT; stdcall;

    /// <summary>
    /// Gets the GOP enable state.
    /// </summary>
    function get_GOP(out pValue: BOOL): HRESULT; stdcall;

    /// <summary>
    /// Enables or disables GOP structure.
    /// </summary>
    function put_GOP(value: BOOL): HRESULT; stdcall;

    /// <summary>
    /// Gets the auto-bitrate adjustment state.
    /// </summary>
    function get_AutoBitrate(out pValue: BOOL): HRESULT; stdcall;

    /// <summary>
    /// Enables or disables automatic bitrate adjustment.
    /// </summary>
    function put_AutoBitrate(value: BOOL): HRESULT; stdcall;

    /// <summary>
    /// Gets the H.264 profile.
    /// </summary>
    function get_Profile(out pValue: Integer): HRESULT; stdcall;

    /// <summary>
    /// Sets the H.264 profile (66=Baseline, 77=Main, 100=High).
    /// </summary>
    function put_Profile(value: Integer): HRESULT; stdcall;

    /// <summary>
    /// Gets the H.264 level.
    /// </summary>
    function get_Level(out pValue: Integer): HRESULT; stdcall;

    /// <summary>
    /// Sets the H.264 level (10-51).
    /// </summary>
    function put_Level(value: Integer): HRESULT; stdcall;

    /// <summary>
    /// Gets the usage mode.
    /// </summary>
    function get_Usage(out pValue: Integer): HRESULT; stdcall;

    /// <summary>
    /// Sets the usage mode (0=Quality, 1=Balanced, 2=Speed).
    /// </summary>
    function put_Usage(value: Integer): HRESULT; stdcall;

    /// <summary>
    /// Gets the sequential timing mode.
    /// </summary>
    function get_SequentialTiming(out pValue: Integer): HRESULT; stdcall;

    /// <summary>
    /// Sets the sequential timing mode.
    /// </summary>
    function put_SequentialTiming(value: Integer): HRESULT; stdcall;

    /// <summary>
    /// Gets the slice intervals.
    /// </summary>
    function get_SliceIntervals(out piIDR: Integer; out piP: Integer): HRESULT; stdcall;

    /// <summary>
    /// Sets the slice intervals for IDR and P frames.
    /// </summary>
    function put_SliceIntervals(var piIDR: Integer; var piP: Integer): HRESULT; stdcall;

    /// <summary>
    /// Gets the maximum bitrate.
    /// </summary>
    function get_MaxBitrate(out plValue: Integer): HRESULT; stdcall;

    /// <summary>
    /// Sets the maximum bitrate for VBR encoding.
    /// </summary>
    function put_MaxBitrate(lValue: Integer): HRESULT; stdcall;

    /// <summary>
    /// Gets the minimum bitrate.
    /// </summary>
    function get_MinBitrate(out plValue: Integer): HRESULT; stdcall;

    /// <summary>
    /// Sets the minimum bitrate for VBR encoding.
    /// </summary>
    function put_MinBitrate(lValue: Integer): HRESULT; stdcall;
  end;
```

## H.264 Profiles and Levels

### Profiles

H.264 profiles define the features and capabilities available for encoding:

**Profile 66 - Baseline Profile**:
- Lowest complexity, best decoder compatibility
- No B-frames, no CABAC entropy coding
- Used for: Video conferencing, mobile devices, web streaming
- Compatibility: All H.264 decoders

**Profile 77 - Main Profile**:
- Medium complexity, good compression
- Supports B-frames, CABAC entropy coding
- Used for: Standard definition broadcast, streaming services
- Better compression than Baseline

**Profile 100 - High Profile**:
- Highest quality, best compression
- Advanced features including 8x8 transforms
- Used for: Blu-ray, HDTV broadcast, high-quality streaming
- Recommended for most professional applications

**Profile 110 - High 10 Profile**:
- 10-bit color depth support
- Used for: Professional production, HDR content

**Profile 122 - High 4:2:2 Profile**:
- 4:2:2 chroma subsampling
- Used for: Professional editing, broadcast production

### Levels

H.264 levels constrain maximum resolution, frame rate, and bitrate:

| Level | Max Resolution | Max Frame Rate | Max Bitrate | Typical Use Case |
|-------|----------------|----------------|-------------|------------------|
| 1.0 (10) | 176x144 | 15 fps | 64 Kbps | Mobile, low res |
| 3.0 (30) | 720x576 | 30 fps | 10 Mbps | SD broadcast |
| 3.1 (31) | 1280x720 | 30 fps | 14 Mbps | 720p HD |
| 4.0 (40) | 1920x1080 | 30 fps | 20 Mbps | 1080p HD |
| 4.1 (41) | 1920x1080 | 30 fps | 50 Mbps | 1080p HD high bitrate |
| 5.0 (50) | 2560x1920 | 30 fps | 135 Mbps | 2K, professional |
| 5.1 (51) | 4096x2304 | 30 fps | 240 Mbps | 4K UHD |
| 5.2 (52) | 4096x2304 | 60 fps | 480 Mbps | 4K UHD 60fps |

**Auto-Selection**: Set level to 0 for automatic selection based on resolution and frame rate.

## Rate Control Modes

### Constant Bitrate (CBR) - Mode 0

**Characteristics**:
- Maintains consistent bitrate throughout encoding
- Predictable file size and network bandwidth usage
- Quality varies based on scene complexity

**Use Cases**:
- Live streaming (RTMP, HLS, DASH)
- Video conferencing
- Broadcast transmission
- Network-constrained scenarios

**Configuration**:
```csharp
h264Encoder.put_RateControl(0);  // CBR mode
h264Encoder.put_Bitrate(5000000); // 5 Mbps fixed
```

### Variable Bitrate (VBR) - Mode 1

**Characteristics**:
- Allocates more bits to complex scenes, fewer to simple scenes
- Better overall quality for the same average bitrate
- File size and bitrate fluctuate

**Use Cases**:
- File-based encoding for storage
- VOD (Video On Demand) content
- Archival and distribution
- When quality is more important than consistent bandwidth

**Configuration**:
```csharp
h264Encoder.put_RateControl(1);     // VBR mode
h264Encoder.put_Bitrate(5000000);   // 5 Mbps target
h264Encoder.put_MinBitrate(3000000); // 3 Mbps minimum
h264Encoder.put_MaxBitrate(8000000); // 8 Mbps maximum
```

## Method Reference

### Bitrate Configuration

#### get_Bitrate / put_Bitrate

Gets or sets the target bitrate for encoding in bits per second.

**Typical Values**:
- **360p (SD)**: 500,000 - 1,500,000 bps (0.5-1.5 Mbps)
- **720p (HD)**: 2,500,000 - 5,000,000 bps (2.5-5 Mbps)
- **1080p (Full HD)**: 5,000,000 - 15,000,000 bps (5-15 Mbps)
- **4K (UHD)**: 20,000,000 - 50,000,000 bps (20-50 Mbps)

**Example**:
```csharp
h264Encoder.put_Bitrate(5000000); // 5 Mbps for 1080p
```

#### get_MaxBitrate / put_MaxBitrate

Gets or sets the maximum bitrate for VBR encoding. Only applicable when rate control is set to VBR (mode 1).

**Recommendation**: Set MaxBitrate to 1.5-2x the target bitrate for VBR encoding.

#### get_MinBitrate / put_MinBitrate

Gets or sets the minimum bitrate for VBR encoding. Only applicable for VBR mode.

**Recommendation**: Set MinBitrate to 0.5-0.7x the target bitrate for VBR encoding.

### Rate Control Methods

#### get_RateControl / put_RateControl

Gets or sets the rate control mode:
- **0**: Constant Bitrate (CBR)
- **1**: Variable Bitrate (VBR)

#### get_AutoBitrate / put_AutoBitrate

Enables or disables automatic bitrate adjustment based on content complexity.

**When enabled**: Encoder automatically adjusts bitrate within configured constraints based on scene complexity, motion, and detail.

**Recommended**: Enable for VBR mode, disable for CBR mode.

### Profile and Level Configuration

#### get_Profile / put_Profile

Gets or sets the H.264 profile:
- **66**: Baseline Profile
- **77**: Main Profile
- **100**: High Profile
- **110**: High 10 Profile
- **122**: High 4:2:2 Profile

**Recommendation**: Use High Profile (100) for most applications. Use Baseline (66) only for maximum compatibility with old devices.

#### get_Level / put_Level

Gets or sets the H.264 level (10 = Level 1.0, 11 = Level 1.1, ..., 51 = Level 5.1, 52 = Level 5.2).

**Auto-Selection**: Set to 0 for automatic level selection based on resolution and frame rate.

### GOP (Group of Pictures) Configuration

#### get_GOP / put_GOP

Enables or disables GOP structure:
- **true**: Normal GOP with I/P/B frames
- **false**: All I-frames (intra-only encoding)

**All I-frames mode**:
- Higher bitrate required
- Better editing capability (every frame is a keyframe)
- No temporal compression
- Use for: Production/editing workflows

**Normal GOP mode** (recommended):
- Efficient compression with I/P/B frame structure
- Lower bitrate for same quality
- Use for: Distribution, streaming, archival

### Slice Interval Configuration

#### get_SliceIntervals / put_SliceIntervals

Gets or sets the slice intervals for IDR (Instantaneous Decoder Refresh) frames and P frames.

**Parameters**:
- `piIDR`: IDR frame interval (keyframe every N frames)
- `piP`: P frame interval

**Typical Values**:
- **Streaming (low latency)**: IDR=30-60 (1-2 seconds at 30fps), P=1
- **Standard encoding**: IDR=120-300 (4-10 seconds), P=1-3
- **Long-form video**: IDR=300+ (10+ seconds), P=3

**IDR Frame Interval**:
- Lower values (30-60): Better seeking, higher bitrate overhead, faster error recovery
- Higher values (240-600): Lower bitrate overhead, slower seeking, slower error recovery

**Example**:
```csharp
int idr = 120;  // Keyframe every 120 frames (4 seconds at 30fps)
int p = 1;      // P frame every frame
h264Encoder.put_SliceIntervals(ref idr, ref p);
```

### Advanced Configuration

#### get_Usage / put_Usage

Sets the encoding usage mode (quality vs. speed trade-off):
- **0**: Quality Mode - Slower encoding, best quality
- **1**: Balanced Mode - Good quality, reasonable speed
- **2**: Speed Mode - Fast encoding, lower quality

**Recommendation**:
- Use Quality Mode (0) for file-based encoding
- Use Balanced Mode (1) for most real-time applications
- Use Speed Mode (2) only when encoding performance is critical

#### get_MbEncoding / put_MbEncoding

Configures macroblock encoding mode, affecting encoding complexity and compression efficiency.

**Note**: Specific values are encoder-dependent. Consult encoder documentation for supported modes.

#### get_SequentialTiming / put_SequentialTiming

Configures sequential timing mode for frame processing.

**Note**: Implementation-specific. Affects frame ordering and presentation timing.

## Usage Examples

### C# Example - High Quality 1080p Encoding

```csharp
using System;
using DirectShowLib;
using VisioForge.DirectShowAPI;

public class H264HighQualityEncoder
{
    public void ConfigureHighQuality1080p(IBaseFilter videoEncoder)
    {
        // Query the H.264 encoder interface
        var h264Encoder = videoEncoder as IH264Encoder;
        if (h264Encoder == null)
        {
            Console.WriteLine("Error: Filter does not support IH264Encoder");
            return;
        }

        // High quality 1080p settings
        h264Encoder.put_Profile(100);           // High Profile
        h264Encoder.put_Level(41);              // Level 4.1 (1080p @ 30fps)
        h264Encoder.put_RateControl(1);         // VBR mode
        h264Encoder.put_Bitrate(10000000);      // 10 Mbps target
        h264Encoder.put_MinBitrate(6000000);    // 6 Mbps minimum
        h264Encoder.put_MaxBitrate(15000000);   // 15 Mbps maximum
        h264Encoder.put_Usage(0);               // Quality mode
        h264Encoder.put_GOP(true);              // Enable GOP structure
        h264Encoder.put_AutoBitrate(true);      // Auto bitrate adjustment

        // Set keyframe interval: 120 frames (4 seconds at 30fps)
        int idr = 120;
        int p = 1;
        h264Encoder.put_SliceIntervals(ref idr, ref p);

        Console.WriteLine("H.264 encoder configured for high-quality 1080p:");
        h264Encoder.get_Bitrate(out int bitrate);
        h264Encoder.get_Profile(out int profile);
        h264Encoder.get_Level(out int level);
        Console.WriteLine($"  Bitrate: {bitrate / 1000000.0:F1} Mbps");
        Console.WriteLine($"  Profile: {profile} (High)");
        Console.WriteLine($"  Level: {level / 10.0:F1}");
    }
}
```

### C# Example - Live Streaming Configuration

```csharp
public class H264LiveStreamingEncoder
{
    public void ConfigureLiveStreaming720p(IBaseFilter videoEncoder)
    {
        var h264Encoder = videoEncoder as IH264Encoder;
        if (h264Encoder == null)
            return;

        // Live streaming 720p settings
        h264Encoder.put_Profile(77);            // Main Profile (good compatibility)
        h264Encoder.put_Level(31);              // Level 3.1 (720p @ 30fps)
        h264Encoder.put_RateControl(0);         // CBR mode for streaming
        h264Encoder.put_Bitrate(3500000);       // 3.5 Mbps constant
        h264Encoder.put_Usage(1);               // Balanced mode
        h264Encoder.put_GOP(true);              // Enable GOP
        h264Encoder.put_AutoBitrate(false);     // Fixed bitrate for streaming

        // Low latency: keyframe every 2 seconds
        int idr = 60;  // 2 seconds at 30fps
        int p = 1;
        h264Encoder.put_SliceIntervals(ref idr, ref p);

        Console.WriteLine("H.264 encoder configured for live streaming");
        Console.WriteLine("  720p @ 3.5 Mbps CBR");
        Console.WriteLine("  Keyframe interval: 2 seconds");
    }
}
```

### C# Example - Fast Encoding for Recording

```csharp
public class H264FastRecording
{
    public void ConfigureFastRecording(IBaseFilter videoEncoder)
    {
        var h264Encoder = videoEncoder as IH264Encoder;
        if (h264Encoder == null)
            return;

        // Fast recording settings
        h264Encoder.put_Profile(66);            // Baseline (fastest encoding)
        h264Encoder.put_Level(40);              // Level 4.0 (1080p @ 30fps)
        h264Encoder.put_RateControl(0);         // CBR mode
        h264Encoder.put_Bitrate(8000000);       // 8 Mbps
        h264Encoder.put_Usage(2);               // Speed mode (fast encoding)
        h264Encoder.put_GOP(true);              // Enable GOP
        h264Encoder.put_AutoBitrate(false);     // Fixed bitrate

        // Longer keyframe interval for faster encoding
        int idr = 300;  // 10 seconds at 30fps
        int p = 1;
        h264Encoder.put_SliceIntervals(ref idr, ref p);

        Console.WriteLine("H.264 encoder configured for fast recording");
    }
}
```

### C++ Example - High Quality Configuration

```cpp
#include <dshow.h>
#include <iostream>
#include "IH264Encoder.h"

void ConfigureH264HighQuality(IBaseFilter* pVideoEncoder)
{
    IH264Encoder* pH264Encoder = NULL;
    HRESULT hr = S_OK;

    // Query the H.264 encoder interface
    hr = pVideoEncoder->QueryInterface(IID_IH264Encoder,
                                       (void**)&pH264Encoder);
    if (FAILED(hr) || !pH264Encoder)
    {
        std::cout << "Error: Filter does not support IH264Encoder" << std::endl;
        return;
    }

    // Configure high quality 1080p encoding
    pH264Encoder->put_Profile(100);           // High Profile
    pH264Encoder->put_Level(41);              // Level 4.1
    pH264Encoder->put_RateControl(1);         // VBR mode
    pH264Encoder->put_Bitrate(10000000);      // 10 Mbps
    pH264Encoder->put_MinBitrate(6000000);    // 6 Mbps min
    pH264Encoder->put_MaxBitrate(15000000);   // 15 Mbps max
    pH264Encoder->put_Usage(0);               // Quality mode
    pH264Encoder->put_GOP(TRUE);              // Enable GOP
    pH264Encoder->put_AutoBitrate(TRUE);      // Auto bitrate

    // Set keyframe interval
    int idr = 120;
    int p = 1;
    pH264Encoder->put_SliceIntervals(&idr, &p);

    // Display configuration
    long bitrate;
    pH264Encoder->get_Bitrate(&bitrate);
    std::cout << "H.264 encoder configured:" << std::endl;
    std::cout << "  Bitrate: " << (bitrate / 1000000.0) << " Mbps" << std::endl;

    pH264Encoder->Release();
}
```

### C++ Example - Live Streaming

```cpp
void ConfigureH264LiveStreaming(IBaseFilter* pVideoEncoder)
{
    IH264Encoder* pH264Encoder = NULL;
    HRESULT hr = pVideoEncoder->QueryInterface(IID_IH264Encoder,
                                               (void**)&pH264Encoder);
    if (SUCCEEDED(hr) && pH264Encoder)
    {
        // Live streaming configuration
        pH264Encoder->put_Profile(77);          // Main Profile
        pH264Encoder->put_Level(31);            // Level 3.1 (720p)
        pH264Encoder->put_RateControl(0);       // CBR for streaming
        pH264Encoder->put_Bitrate(3500000);     // 3.5 Mbps
        pH264Encoder->put_Usage(1);             // Balanced mode
        pH264Encoder->put_GOP(TRUE);            // Enable GOP
        pH264Encoder->put_AutoBitrate(FALSE);   // Fixed bitrate

        // Low latency keyframes
        int idr = 60;  // 2 seconds
        int p = 1;
        pH264Encoder->put_SliceIntervals(&idr, &p);

        std::cout << "H.264 live streaming configured" << std::endl;
        pH264Encoder->Release();
    }
}
```

### Delphi Example - High Quality Encoding

```delphi
uses
  DirectShow9, ActiveX;

procedure ConfigureH264HighQuality(VideoEncoder: IBaseFilter);
var
  H264Encoder: IH264Encoder;
  IDR, P: Integer;
  Bitrate: Integer;
  hr: HRESULT;
begin
  // Query the H.264 encoder interface
  hr := VideoEncoder.QueryInterface(IID_IH264Encoder, H264Encoder);
  if Failed(hr) or (H264Encoder = nil) then
  begin
    WriteLn('Error: Filter does not support IH264Encoder');
    Exit;
  end;

  try
    // Configure high quality 1080p encoding
    H264Encoder.put_Profile(100);           // High Profile
    H264Encoder.put_Level(41);              // Level 4.1
    H264Encoder.put_RateControl(1);         // VBR mode
    H264Encoder.put_Bitrate(10000000);      // 10 Mbps
    H264Encoder.put_MinBitrate(6000000);    // 6 Mbps minimum
    H264Encoder.put_MaxBitrate(15000000);   // 15 Mbps maximum
    H264Encoder.put_Usage(0);               // Quality mode
    H264Encoder.put_GOP(True);              // Enable GOP
    H264Encoder.put_AutoBitrate(True);      // Auto bitrate

    // Set keyframe interval
    IDR := 120;
    P := 1;
    H264Encoder.put_SliceIntervals(IDR, P);

    // Display configuration
    H264Encoder.get_Bitrate(Bitrate);
    WriteLn('H.264 encoder configured for high quality:');
    WriteLn('  Bitrate: ', Bitrate / 1000000:0:1, ' Mbps');
  finally
    H264Encoder := nil;
  end;
end;
```

### Delphi Example - Live Streaming

```delphi
procedure ConfigureH264LiveStreaming(VideoEncoder: IBaseFilter);
var
  H264Encoder: IH264Encoder;
  IDR, P: Integer;
begin
  if Succeeded(VideoEncoder.QueryInterface(IID_IH264Encoder, H264Encoder)) then
  begin
    try
      // Live streaming configuration
      H264Encoder.put_Profile(77);          // Main Profile
      H264Encoder.put_Level(31);            // Level 3.1 (720p)
      H264Encoder.put_RateControl(0);       // CBR mode
      H264Encoder.put_Bitrate(3500000);     // 3.5 Mbps
      H264Encoder.put_Usage(1);             // Balanced mode
      H264Encoder.put_GOP(True);            // Enable GOP
      H264Encoder.put_AutoBitrate(False);   // Fixed bitrate

      // Low latency keyframes
      IDR := 60;  // 2 seconds at 30fps
      P := 1;
      H264Encoder.put_SliceIntervals(IDR, P);

      WriteLn('H.264 live streaming configured');
    finally
      H264Encoder := nil;
    end;
  end;
end;
```

## Best Practices

### Bitrate Selection Guidelines

**Resolution-Based Recommendations**:

| Resolution | CBR (Streaming) | VBR Target | VBR Min-Max |
|-----------|----------------|------------|-------------|
| 360p (SD) | 0.8 Mbps | 1 Mbps | 0.5 - 1.5 Mbps |
| 480p (SD) | 1.5 Mbps | 2 Mbps | 1 - 3 Mbps |
| 720p (HD) | 3 Mbps | 4 Mbps | 2.5 - 6 Mbps |
| 1080p (Full HD) | 6 Mbps | 8 Mbps | 5 - 12 Mbps |
| 1440p (2K) | 12 Mbps | 16 Mbps | 10 - 24 Mbps |
| 2160p (4K UHD) | 25 Mbps | 35 Mbps | 20 - 50 Mbps |

**Content Type Adjustments**:
- **Low motion** (presentations, talking head): Use 60-70% of recommended bitrate
- **Medium motion** (standard video): Use recommended bitrate
- **High motion** (sports, action): Use 120-150% of recommended bitrate

### Profile Selection

**Use Baseline Profile (66) when**:
- Maximum device compatibility required
- Targeting old mobile devices or web browsers
- Real-time encoding performance is critical

**Use Main Profile (77) when**:
- Good balance between quality and compatibility needed
- Live streaming to mixed audiences
- Standard broadcast applications

**Use High Profile (100) when** (recommended):
- Best quality is required
- Modern device compatibility is acceptable (post-2010 devices)
- File-based encoding for distribution
- **Most production scenarios**

### GOP Structure Recommendations

**Streaming Applications**:
- IDR interval: 60-120 frames (2-4 seconds at 30fps)
- Shorter intervals: Better seeking, faster error recovery, slightly higher bitrate
- Longer intervals: Lower bitrate overhead, but slower seeking

**File-Based Encoding**:
- IDR interval: 240-300 frames (8-10 seconds at 30fps)
- Balance between file size and seeking capability

**Low-Latency Applications** (video conferencing):
- IDR interval: 30-60 frames (1-2 seconds at 30fps)
- Short intervals reduce lag from dropped frames

**All-Intra Encoding** (editing workflows):
- Disable GOP (`put_GOP(false)`)
- Every frame is a keyframe
- Higher bitrate required (typically 3-5x normal encoding)
- Perfect frame-accurate editing

### Usage Mode Selection

**Quality Mode (0)**:
- Slowest encoding, best quality
- Use for: File-based encoding, archival, VOD content
- Not suitable for real-time encoding on slower hardware

**Balanced Mode (1)** (recommended):
- Good quality, reasonable performance
- Use for: Most real-time applications, live streaming
- Best choice for general-purpose encoding

**Speed Mode (2)**:
- Fastest encoding, lower quality
- Use for: High-resolution real-time encoding on limited hardware
- Screen recording, surveillance applications

## Troubleshooting

### Low Video Quality

**Symptoms**: Blocky artifacts, blurring, loss of detail

**Possible Causes**:
1. Bitrate too low for resolution
2. Wrong profile selection
3. GOP interval too long
4. Usage mode set to Speed instead of Quality

**Solutions**:
- Increase bitrate to recommended levels (see table above)
- Switch to High Profile (100) for better compression
- Shorten IDR interval to 120-180 frames
- Use Balanced (1) or Quality (0) usage mode
- For VBR, increase minimum bitrate

### Encoding Too Slow / Cannot Keep Up

**Symptoms**: Dropped frames, encoding slower than real-time

**Solutions**:
1. Switch to Baseline Profile (66) for faster encoding
2. Set Usage mode to Speed (2)
3. Reduce bitrate to lower computational requirements
4. Increase IDR interval (longer GOP = less processing)
5. Consider hardware encoder (NVENC, QuickSync) instead

### Large File Sizes

**Symptoms**: Files larger than expected

**Possible Causes**:
1. Bitrate too high for target quality
2. CBR mode with conservative bitrate setting
3. GOP disabled (all I-frames)
4. Wrong level setting

**Solutions**:
- Switch from CBR to VBR for variable content
- Enable GOP structure (`put_GOP(true)`)
- Reduce target bitrate
- Adjust min/max bitrate range for VBR
- Use High Profile (100) for better compression

### Streaming Compatibility Issues

**Symptoms**: Video plays on some devices but not others

**Possible Causes**:
1. Profile too advanced (High Profile not supported on old devices)
2. Level too high for device capabilities
3. Incorrect slice configuration

**Solutions**:
- Use Main Profile (77) or Baseline Profile (66) for maximum compatibility
- Set level to 0 for automatic selection
- Test on target devices
- Verify player/device H.264 capabilities

### Seeking Issues / Slow Scrubbing

**Symptoms**: Slow or inaccurate seeking in encoded video

**Cause**: IDR interval too long (keyframes too far apart)

**Solutions**:
- Reduce IDR interval to 60-120 frames (2-4 seconds)
- For editing workflows, consider all-intra encoding (`put_GOP(false)`)
- Shorter IDR intervals improve seeking at cost of slightly higher bitrate

---
## See Also
- [NVENC Encoder Interface](nvenc.md) - NVIDIA hardware H.264/HEVC encoding
- [Video Codecs Reference](../codecs-reference.md)
- [Encoding Filters Pack Overview](../index.md)
- [MP4 Muxer Interface](mp4-muxer.md)