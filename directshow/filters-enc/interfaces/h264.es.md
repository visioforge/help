---
title: Referencia de la Interfaz del Codificador H.264
description: Interfaz DirectShow del codificador H.264/AVC con control de bitrate, perfiles/niveles, estructura GOP y parámetros avanzados de codificación.
---

# Referencia de la Interfaz del Codificador H.264

## Descripción general

La interfaz **IH264Encoder** ofrece un control integral sobre la codificación de video H.264/AVC (Advanced Video Coding) dentro de gráficos de filtros DirectShow. H.264 es el estándar de facto para distribución, transmisión y difusión de video gracias a su elevada eficiencia de compresión.

Con esta interfaz es posible configurar perfiles de codificación, modos de control de tasa, estructura GOP (Group of Pictures), modos de codificación de macro-bloques y parámetros temporales avanzados. Esto permite optimizar la calidad visual y el tamaño de archivo en escenarios como streaming en vivo, difusión televisiva, grabación o archivado.

**GUID de la interfaz**: `{09FA2EA3-4773-41a8-90DC-9499D4061E9F}`

**Hereda de**: `IUnknown`

## Definiciones de Interfaz

### Definición en C#

```csharp
using System;
using System.Runtime.InteropServices;

namespace VisioForge.DirectShowAPI
{
	/// <summary>
	/// Interfaz de configuración del codificador H.264/AVC.
	/// Ofrece control sobre parámetros de bitrate, perfiles/niveles, GOP y modos de control de tasa.
	/// </summary>
	[ComImport]
	[Guid("09FA2EA3-4773-41a8-90DC-9499D4061E9F")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	public interface IH264Encoder
	{
		/// <summary>
		/// Obtiene el bitrate objetivo en bits por segundo.
		/// </summary>
		/// <param name="plValue">Recibe el valor de bitrate (bps)</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int get_Bitrate([Out] out int plValue);

		/// <summary>
		/// Establece el bitrate objetivo en bits por segundo.
		/// </summary>
		/// <param name="lValue">Bitrate en bps. Rango típico: 500.000 a 50.000.000</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int put_Bitrate([In] int lValue);

		/// <summary>
		/// Obtiene el modo de control de tasa.
		/// </summary>
		/// <param name="pValue">0 = CBR, 1 = VBR</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int get_RateControl([Out] out int pValue);

		/// <summary>
		/// Configura el modo de control de tasa (CBR o VBR).
		/// </summary>
		/// <param name="value">0 = CBR, 1 = VBR</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int put_RateControl([In] int value);

		/// <summary>
		/// Obtiene el modo de codificación de macro-bloques.
		/// </summary>
		/// <param name="pValue">Recibe el modo configurado</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int get_MbEncoding([Out] out int pValue);

		/// <summary>
		/// Define el modo de codificación de macro-bloques.
		/// </summary>
		/// <param name="value">Valor específico según la implementación</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int put_MbEncoding([In] int value);

		/// <summary>
		/// Obtiene el estado de habilitación del GOP (Group of Pictures).
		/// </summary>
		/// <param name="pValue">true si el GOP está habilitado</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int get_GOP([Out] [MarshalAs(UnmanagedType.Bool)] out bool pValue);

		/// <summary>
		/// Habilita o deshabilita la estructura GOP.
		/// </summary>
		/// <param name="value">true para habilitar GOP, false para solo I-frames</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int put_GOP([In] [MarshalAs(UnmanagedType.Bool)] bool value);

		/// <summary>
		/// Obtiene el estado del ajuste automático de bitrate.
		/// </summary>
		/// <param name="pValue">true si auto bitrate está habilitado</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int get_AutoBitrate([Out] [MarshalAs(UnmanagedType.Bool)] out bool pValue);

		/// <summary>
		/// Activa o desactiva el ajuste automático de bitrate en función de la complejidad.
		/// </summary>
		/// <param name="value">true para habilitar auto bitrate</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int put_AutoBitrate([In] [MarshalAs(UnmanagedType.Bool)] bool value);

		/// <summary>
		/// Obtiene el perfil H.264 actual.
		/// </summary>
		/// <param name="pValue">66=Baseline, 77=Main, 100=High...</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int get_Profile([Out] out int pValue);

		/// <summary>
		/// Define el perfil H.264 (Baseline, Main, High, etc.).
		/// </summary>
		/// <param name="value">Valor del perfil según la especificación</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int put_Profile([In] int value);

		/// <summary>
		/// Obtiene el nivel H.264 configurado.
		/// </summary>
		/// <param name="pValue">Nivel expresado como entero (ej. 41 = 4.1)</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int get_Level([Out] out int pValue);

		/// <summary>
		/// Configura el nivel H.264, el cual limita resolución, bitrate y FPS.
		/// </summary>
		/// <param name="value">Valor entero de nivel (10 = 1.0, 51 = 5.1)</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int put_Level([In] int value);

		/// <summary>
		/// Obtiene el modo de uso (calidad vs. velocidad).
		/// </summary>
		/// <param name="pValue">0=Calidad, 1=Equilibrado, 2=Velocidad</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int get_Usage([Out] out int pValue);

		/// <summary>
		/// Define el modo de uso para equilibrar calidad y rendimiento.
		/// </summary>
		/// <param name="value">0=Calidad, 1=Equilibrado, 2=Velocidad</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int put_Usage([In] int value);

		/// <summary>
		/// Obtiene el modo de temporización secuencial.
		/// </summary>
		/// <param name="pValue">Valor de temporización configurado</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int get_SequentialTiming([Out] out int pValue);

		/// <summary>
		/// Configura el modo de temporización secuencial para el procesamiento de cuadros.
		/// </summary>
		/// <param name="value">Valor específico del modo</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int put_SequentialTiming([In] int value);

		/// <summary>
		/// Obtiene los intervalos de slices (IDR y P).
		/// </summary>
		/// <param name="piIDR">Intervalo de cuadros IDR</param>
		/// <param name="piP">Intervalo de cuadros P</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int get_SliceIntervals([Out] out int piIDR, [Out] out int piP);

		/// <summary>
		/// Establece los intervalos de slices para cuadros IDR y P.
		/// </summary>
		/// <param name="piIDR">Intervalo para IDR (keyframes)</param>
		/// <param name="piP">Intervalo para cuadros P</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int put_SliceIntervals([In] ref int piIDR, [In] ref int piP);

		/// <summary>
		/// Obtiene el bitrate máximo (solo VBR).
		/// </summary>
		/// <param name="plValue">Bitrate máximo en bps</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int get_MaxBitrate([Out] out int plValue);

		/// <summary>
		/// Establece el bitrate máximo para VBR.
		/// </summary>
		/// <param name="lValue">Bitrate máximo en bps</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int put_MaxBitrate([In] int lValue);

		/// <summary>
		/// Obtiene el bitrate mínimo (solo VBR).
		/// </summary>
		/// <param name="plValue">Bitrate mínimo en bps</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int get_MinBitrate([Out] out int plValue);

		/// <summary>
		/// Establece el bitrate mínimo para VBR.
		/// </summary>
		/// <param name="lValue">Bitrate mínimo en bps</param>
		/// <returns>HRESULT (0 para éxito)</returns>
		[PreserveSig]
		int put_MinBitrate([In] int lValue);
	}
}
```

### Definición en C++

```cpp
#include <unknwn.h>

// {09FA2EA3-4773-41a8-90DC-9499D4061E9F}
DEFINE_GUID(IID_IH264Encoder,
	0x09fa2ea3, 0x4773, 0x41a8, 0x90, 0xdc, 0x94, 0x99, 0xd4, 0x06, 0x1e, 0x9f);

/// <summary>
/// Interfaz de configuración del codificador H.264/AVC.
/// Proporciona control completo sobre parámetros de codificación.
/// </summary>
DECLARE_INTERFACE_(IH264Encoder, IUnknown)
{
	/// <summary>
	/// Obtiene el bitrate objetivo.
	/// </summary>
	STDMETHOD(get_Bitrate)(THIS_
		long* plValue
		) PURE;

	/// <summary>
	/// Establece el bitrate objetivo.
	/// </summary>
	STDMETHOD(put_Bitrate)(THIS_
		long lValue
		) PURE;

	/// <summary>
	/// Obtiene el modo de control de tasa.
	/// </summary>
	STDMETHOD(get_RateControl)(THIS_
		int* pValue
		) PURE;

	/// <summary>
	/// Configura el modo de control de tasa (CBR/VBR).
	/// </summary>
	STDMETHOD(put_RateControl)(THIS_
		int value
		) PURE;

	/// <summary>
	/// Obtiene el modo de codificación de macro-bloques.
	/// </summary>
	STDMETHOD(get_MbEncoding)(THIS_
		int* pValue
		) PURE;

	/// <summary>
	/// Define el modo de codificación de macro-bloques.
	/// </summary>
	STDMETHOD(put_MbEncoding)(THIS_
		int value
		) PURE;

	/// <summary>
	/// Obtiene el estado del GOP.
	/// </summary>
	STDMETHOD(get_GOP)(THIS_
		BOOL* pValue
		) PURE;

	/// <summary>
	/// Habilita o deshabilita la estructura GOP.
	/// </summary>
	STDMETHOD(put_GOP)(THIS_
		BOOL value
		) PURE;

	/// <summary>
	/// Obtiene el estado del auto bitrate.
	/// </summary>
	STDMETHOD(get_AutoBitrate)(THIS_
		BOOL* pValue
		) PURE;

	/// <summary>
	/// Activa o desactiva el auto bitrate.
	/// </summary>
	STDMETHOD(put_AutoBitrate)(THIS_
		BOOL value
		) PURE;

	/// <summary>
	/// Obtiene el perfil H.264.
	/// </summary>
	STDMETHOD(get_Profile)(THIS_
		int* pValue
		) PURE;

	/// <summary>
	/// Establece el perfil H.264.
	/// </summary>
	STDMETHOD(put_Profile)(THIS_
		int value
		) PURE;

	/// <summary>
	/// Obtiene el nivel H.264.
	/// </summary>
	STDMETHOD(get_Level)(THIS_
		int* pValue
		) PURE;

	/// <summary>
	/// Configura el nivel H.264.
	/// </summary>
	STDMETHOD(put_Level)(THIS_
		int value
		) PURE;

	/// <summary>
	/// Obtiene el modo de uso (calidad/velocidad).
	/// </summary>
	STDMETHOD(get_Usage)(THIS_
		int* pValue
		) PURE;

	/// <summary>
	/// Define el modo de uso.
	/// </summary>
	STDMETHOD(put_Usage)(THIS_
		int value
		) PURE;

	/// <summary>
	/// Obtiene el modo de temporización secuencial.
	/// </summary>
	STDMETHOD(get_SequentialTiming)(THIS_
		int* pValue
		) PURE;

	/// <summary>
	/// Configura la temporización secuencial.
	/// </summary>
	STDMETHOD(put_SequentialTiming)(THIS_
		int value
		) PURE;

	/// <summary>
	/// Obtiene los intervalos de slices para IDR y P.
	/// </summary>
	STDMETHOD(get_SliceIntervals)(THIS_
		int* piIDR,
		int* piP
		) PURE;

	/// <summary>
	/// Configura los intervalos de slices para IDR y P.
	/// </summary>
	STDMETHOD(put_SliceIntervals)(THIS_
		int* piIDR,
		int* piP
		) PURE;

	/// <summary>
	/// Obtiene el bitrate máximo (VBR).
	/// </summary>
	STDMETHOD(get_MaxBitrate)(THIS_
		long* plValue
		) PURE;

	/// <summary>
	/// Establece el bitrate máximo (VBR).
	/// </summary>
	STDMETHOD(put_MaxBitrate)(THIS_
		long lValue
		) PURE;

	/// <summary>
	/// Obtiene el bitrate mínimo (VBR).
	/// </summary>
	STDMETHOD(get_MinBitrate)(THIS_
		long* plValue
		) PURE;

	/// <summary>
	/// Establece el bitrate mínimo (VBR).
	/// </summary>
	STDMETHOD(put_MinBitrate)(THIS_
		long lValue
		) PURE;
};
```

### Definición en Delphi

```delphi
uses
  ActiveX, ComObj;

const
  IID_IH264Encoder: TGUID = '{09FA2EA3-4773-41a8-90DC-9499D4061E9F}';

type
  /// <summary>
  /// Interfaz de configuración del codificador H.264/AVC.
  /// </summary>
  IH264Encoder = interface(IUnknown)
	['{09FA2EA3-4773-41a8-90DC-9499D4061E9F}']

	/// <summary>
	/// Obtiene el bitrate objetivo.
	/// </summary>
	function get_Bitrate(out plValue: Integer): HRESULT; stdcall;

	/// <summary>
	/// Establece el bitrate objetivo.
	/// </summary>
	function put_Bitrate(lValue: Integer): HRESULT; stdcall;

	/// <summary>
	/// Obtiene el modo de control de tasa.
	/// </summary>
	function get_RateControl(out pValue: Integer): HRESULT; stdcall;

	/// <summary>
	/// Configura el modo de control de tasa (0=CBR, 1=VBR).
	/// </summary>
	function put_RateControl(value: Integer): HRESULT; stdcall;

	/// <summary>
	/// Obtiene el modo de codificación de macro-bloques.
	/// </summary>
	function get_MbEncoding(out pValue: Integer): HRESULT; stdcall;

	/// <summary>
	/// Define el modo de codificación de macro-bloques.
	/// </summary>
	function put_MbEncoding(value: Integer): HRESULT; stdcall;

	/// <summary>
	/// Obtiene el estado del GOP.
	/// </summary>
	function get_GOP(out pValue: BOOL): HRESULT; stdcall;

	/// <summary>
	/// Habilita o deshabilita la estructura GOP.
	/// </summary>
	function put_GOP(value: BOOL): HRESULT; stdcall;

	/// <summary>
	/// Obtiene el estado del auto bitrate.
	/// </summary>
	function get_AutoBitrate(out pValue: BOOL): HRESULT; stdcall;

	/// <summary>
	/// Activa o desactiva el auto bitrate.
	/// </summary>
	function put_AutoBitrate(value: BOOL): HRESULT; stdcall;

	/// <summary>
	/// Obtiene el perfil H.264.
	/// </summary>
	function get_Profile(out pValue: Integer): HRESULT; stdcall;

	/// <summary>
	/// Establece el perfil H.264 (66=Baseline, 77=Main, 100=High).
	/// </summary>
	function put_Profile(value: Integer): HRESULT; stdcall;

	/// <summary>
	/// Obtiene el nivel H.264.
	/// </summary>
	function get_Level(out pValue: Integer): HRESULT; stdcall;

	/// <summary>
	/// Configura el nivel H.264 (10-52).
	/// </summary>
	function put_Level(value: Integer): HRESULT; stdcall;

	/// <summary>
	/// Obtiene el modo de uso.
	/// </summary>
	function get_Usage(out pValue: Integer): HRESULT; stdcall;

	/// <summary>
	/// Establece el modo de uso (0=Calidad, 1=Equilibrado, 2=Velocidad).
	/// </summary>
	function put_Usage(value: Integer): HRESULT; stdcall;

	/// <summary>
	/// Obtiene el modo de temporización secuencial.
	/// </summary>
	function get_SequentialTiming(out pValue: Integer): HRESULT; stdcall;

	/// <summary>
	/// Configura el modo de temporización secuencial.
	/// </summary>
	function put_SequentialTiming(value: Integer): HRESULT; stdcall;

	/// <summary>
	/// Obtiene los intervalos de slices.
	/// </summary>
	function get_SliceIntervals(out piIDR: Integer; out piP: Integer): HRESULT; stdcall;

	/// <summary>
	/// Configura los intervalos de slices para IDR y P.
	/// </summary>
	function put_SliceIntervals(var piIDR: Integer; var piP: Integer): HRESULT; stdcall;

	/// <summary>
	/// Obtiene el bitrate máximo (VBR).
	/// </summary>
	function get_MaxBitrate(out plValue: Integer): HRESULT; stdcall;

	/// <summary>
	/// Establece el bitrate máximo (VBR).
	/// </summary>
	function put_MaxBitrate(lValue: Integer): HRESULT; stdcall;

	/// <summary>
	/// Obtiene el bitrate mínimo (VBR).
	/// </summary>
	function get_MinBitrate(out plValue: Integer): HRESULT; stdcall;

	/// <summary>
	/// Establece el bitrate mínimo (VBR).
	/// </summary>
	function put_MinBitrate(lValue: Integer): HRESULT; stdcall;
  end;
```

## Perfiles y Niveles H.264

### Perfiles

Los perfiles determinan las capacidades disponibles durante la codificación:

**Perfil 66 - Baseline**:
- Menor complejidad y máxima compatibilidad
- Sin B-frames ni codificación CABAC
- Uso: Videoconferencias, dispositivos móviles, streaming web
- Compatible con todos los decodificadores H.264

**Perfil 77 - Main**:
- Complejidad media con buena compresión
- Soporta B-frames y CABAC
- Uso: Difusión SD, servicios OTT
- Mejor compresión que Baseline

**Perfil 100 - High**:
- Mayor calidad y eficiencia
- Incluye transformadas 8x8 y herramientas avanzadas
- Uso: Blu-ray, HDTV, streaming premium
- Recomendado para la mayoría de escenarios profesionales

**Perfil 110 - High 10**:
- Soporte para profundidad de color de 10 bits
- Uso: Producción profesional, contenido HDR

**Perfil 122 - High 4:2:2**:
- Submuestreo de crominancia 4:2:2
- Uso: Edición y producción broadcast

### Niveles

Los niveles limitan resolución máxima, cuadro por segundo y bitrate:

| Nivel | Resolución máx. | FPS máx. | Bitrate máx. | Uso típico |
|-------|-----------------|----------|--------------|------------|
| 1.0 (10) | 176x144 | 15 fps | 64 Kbps | Dispositivos móviles, baja resolución |
| 3.0 (30) | 720x576 | 30 fps | 10 Mbps | Difusión SD |
| 3.1 (31) | 1280x720 | 30 fps | 14 Mbps | HD 720p |
| 4.0 (40) | 1920x1080 | 30 fps | 20 Mbps | Full HD 1080p |
| 4.1 (41) | 1920x1080 | 30 fps | 50 Mbps | 1080p con alto bitrate |
| 5.0 (50) | 2560x1920 | 30 fps | 135 Mbps | 2K profesional |
| 5.1 (51) | 4096x2304 | 30 fps | 240 Mbps | 4K UHD |
| 5.2 (52) | 4096x2304 | 60 fps | 480 Mbps | 4K UHD a 60 fps |

**Selección automática**: establezca el nivel en `0` para que el encoder determine el valor óptimo según resolución y FPS.

## Modos de Control de Tasa

### Bitrate Constante (CBR) - Modo 0

**Características**:
- Mantiene un bitrate estable durante toda la codificación
- Permite predecir tamaño de archivo y uso de ancho de banda
- La calidad varía en función de la complejidad de la escena

**Casos de uso**:
- Streaming en vivo (RTMP, HLS, DASH)
- Videoconferencias
- Transmisiones broadcast
- Escenarios con ancho de banda fijo

**Configuración**:

```csharp
h264Encoder.put_RateControl(0);   // Modo CBR
h264Encoder.put_Bitrate(5000000); // 5 Mbps fijos
```

### Bitrate Variable (VBR) - Modo 1

**Características**:
- Asigna más bits a escenas complejas y menos a escenas simples
- Mayor calidad global con el mismo bitrate medio
- El bitrate instantáneo fluctúa según el contenido

**Casos de uso**:
- Codificación para almacenamiento
- Contenido VOD
- Archivos maestros y distribución
- Cuando la calidad prima sobre un bitrate constante

**Configuración**:

```csharp
h264Encoder.put_RateControl(1);      // Modo VBR
h264Encoder.put_Bitrate(5000000);    // Objetivo 5 Mbps
h264Encoder.put_MinBitrate(3000000); // Mínimo 3 Mbps
h264Encoder.put_MaxBitrate(8000000); // Máximo 8 Mbps
```

## Referencia de Métodos

### Configuración de Bitrate

#### get_Bitrate / put_Bitrate

Obtiene o establece el bitrate objetivo en bits por segundo.

**Valores típicos**:
- **360p (SD)**: 0.5 - 1.5 Mbps
- **720p (HD)**: 2.5 - 5 Mbps
- **1080p (Full HD)**: 5 - 15 Mbps
- **4K (UHD)**: 20 - 50 Mbps

```csharp
h264Encoder.put_Bitrate(5000000); // 5 Mbps para 1080p
```

#### get_MaxBitrate / put_MaxBitrate

Define el bitrate máximo cuando se usa VBR. Recomiende asignar 1.5-2 veces el bitrate objetivo.

#### get_MinBitrate / put_MinBitrate

Define el bitrate mínimo en VBR. Habitualmente 0.5-0.7 veces el bitrate objetivo.

### Métodos de Control de Tasa

#### get_RateControl / put_RateControl

Selecciona el modo de control de tasa:
- `0`: Bitrate constante (CBR)
- `1`: Bitrate variable (VBR)

#### get_AutoBitrate / put_AutoBitrate

Activa el ajuste automático de bitrate según la complejidad de la escena.

- **Activado**: El codificador ajusta el bitrate dentro de los límites configurados.
- **Recomendado**: Activar en VBR, desactivar en CBR.

### Configuración de Perfil y Nivel

#### get_Profile / put_Profile

Establece el perfil H.264:
- `66`: Baseline
- `77`: Main
- `100`: High
- `110`: High 10
- `122`: High 4:2:2

**Recomendación**: Utilice High (100) para la mayoría de las aplicaciones modernas. Emplee Baseline (66) solo cuando la compatibilidad heredada sea crítica.

#### get_Level / put_Level

Configura el nivel H.264 (10 = 1.0, 11 = 1.1, ..., 51 = 5.1, 52 = 5.2). Use `0` para selección automática.

### Configuración de GOP (Group of Pictures)

#### get_GOP / put_GOP

- **true**: GOP normal con cuadros I/P/B (recomendado)
- **false**: Solo I-frames (intra), ideal para edición pero requiere mucho más bitrate

**Modo solo I-frames**:
- Cada cuadro es clave
- Edición cuadro a cuadro sin pérdida
- Bitrate 3-5x mayor

**GOP normal**:
- Mejor compresión para distribución/streaming
- Menor bitrate con misma calidad

### Configuración de Intervalos de Slice

#### get_SliceIntervals / put_SliceIntervals

Controla el intervalo entre cuadros IDR y la frecuencia de cuadros P.

**Parámetros**:
- `piIDR`: cada cuántos cuadros se inserta un IDR (keyframe)
- `piP`: intervalo entre cuadros P

**Valores recomendados**:
- **Streaming de baja latencia**: IDR = 30-60 (1-2 s a 30 fps), P = 1
- **Codificación estándar**: IDR = 120-300 (4-10 s), P = 1-3
- **Videos largos**: IDR >= 300, P = 3

**Intervalo IDR**:
- Bajo (30-60): mejor búsqueda y recuperación, mayor overhead
- Alto (240-600): menor bitrate, peor búsqueda

```csharp
int idr = 120; // Keyframe cada 4 s a 30 fps
int p = 1;     // Cuadros P cada cuadro
h264Encoder.put_SliceIntervals(ref idr, ref p);
```

### Configuración Avanzada

#### get_Usage / put_Usage

Controla la relación calidad/velocidad:
- `0`: Modo calidad (más lento, mejor resultado)
- `1`: Modo equilibrado (recomendado para tiempo real)
- `2`: Modo velocidad (prioriza rendimiento)

#### get_MbEncoding / put_MbEncoding

Configura el modo de codificación de macro-bloques. Los valores exactos dependen de la implementación del codificador.

#### get_SequentialTiming / put_SequentialTiming

Ajusta el modo de temporización secuencial para el procesamiento y presentación de cuadros (dependiente de la implementación).

## Ejemplos de Uso

### Ejemplo en C# – Codificación 1080p de Alta Calidad

```csharp
using System;
using DirectShowLib;
using VisioForge.DirectShowAPI;

public class H264HighQualityEncoder
{
	public void ConfigureHighQuality1080p(IBaseFilter videoEncoder)
	{
		// Consultar la interfaz IH264Encoder
		var h264Encoder = videoEncoder as IH264Encoder;
		if (h264Encoder == null)
		{
			Console.WriteLine("Error: El filtro no soporta IH264Encoder");
			return;
		}

		// Parámetros para 1080p de alta calidad
		h264Encoder.put_Profile(100);          // High Profile
		h264Encoder.put_Level(41);             // Nivel 4.1 (1080p @ 30 fps)
		h264Encoder.put_RateControl(1);        // Modo VBR
		h264Encoder.put_Bitrate(10000000);     // Objetivo 10 Mbps
		h264Encoder.put_MinBitrate(6000000);   // 6 Mbps mínimo
		h264Encoder.put_MaxBitrate(15000000);  // 15 Mbps máximo
		h264Encoder.put_Usage(0);              // Modo calidad
		h264Encoder.put_GOP(true);             // Habilitar GOP
		h264Encoder.put_AutoBitrate(true);     // Auto bitrate

		int idr = 120; // Keyframe cada 4 s
		int p = 1;
		h264Encoder.put_SliceIntervals(ref idr, ref p);

		Console.WriteLine("Codificador H.264 configurado para 1080p de alta calidad:");
		h264Encoder.get_Bitrate(out int bitrate);
		h264Encoder.get_Profile(out int profile);
		h264Encoder.get_Level(out int level);
		Console.WriteLine($"  Bitrate: {bitrate / 1000000.0:F1} Mbps");
		Console.WriteLine($"  Perfil: {profile} (High)");
		Console.WriteLine($"  Nivel: {level / 10.0:F1}");
	}
}
```

### Ejemplo en C# – Streaming en Vivo 720p

```csharp
public class H264LiveStreamingEncoder
{
	public void ConfigureLiveStreaming720p(IBaseFilter videoEncoder)
	{
		var h264Encoder = videoEncoder as IH264Encoder;
		if (h264Encoder == null)
			return;

		// Ajustes para streaming 720p
		h264Encoder.put_Profile(77);           // Main Profile
		h264Encoder.put_Level(31);             // Nivel 3.1 (720p @ 30 fps)
		h264Encoder.put_RateControl(0);        // Modo CBR
		h264Encoder.put_Bitrate(3500000);      // 3.5 Mbps
		h264Encoder.put_Usage(1);              // Modo equilibrado
		h264Encoder.put_GOP(true);             // Habilitar GOP
		h264Encoder.put_AutoBitrate(false);    // Bitrate fijo

		int idr = 60; // Keyframe cada 2 s
		int p = 1;
		h264Encoder.put_SliceIntervals(ref idr, ref p);

		Console.WriteLine("Streaming H.264 configurado para 720p @ 3.5 Mbps");
	}
}
```

### Ejemplo en C# – Codificación Rápida para Grabación

```csharp
public class H264FastRecording
{
	public void ConfigureFastRecording(IBaseFilter videoEncoder)
	{
		var h264Encoder = videoEncoder as IH264Encoder;
		if (h264Encoder == null)
			return;

		h264Encoder.put_Profile(66);           // Baseline (más veloz)
		h264Encoder.put_Level(40);             // Nivel 4.0 (1080p)
		h264Encoder.put_RateControl(0);        // CBR
		h264Encoder.put_Bitrate(8000000);      // 8 Mbps
		h264Encoder.put_Usage(2);              // Modo velocidad
		h264Encoder.put_GOP(true);
		h264Encoder.put_AutoBitrate(false);

		int idr = 300; // Keyframe cada 10 s
		int p = 1;
		h264Encoder.put_SliceIntervals(ref idr, ref p);

		Console.WriteLine("Codificador H.264 optimizado para grabación rápida");
	}
}
```

### Ejemplo en C++ – Configuración de Alta Calidad

```cpp
#include <dshow.h>
#include <iostream>
#include "IH264Encoder.h"

void ConfigureH264HighQuality(IBaseFilter* pVideoEncoder)
{
	IH264Encoder* pH264Encoder = NULL;
	HRESULT hr = pVideoEncoder->QueryInterface(IID_IH264Encoder,
											   (void**)&pH264Encoder);
	if (FAILED(hr) || !pH264Encoder)
	{
		std::cout << "Error: El filtro no soporta IH264Encoder" << std::endl;
		return;
	}

	pH264Encoder->put_Profile(100);
	pH264Encoder->put_Level(41);
	pH264Encoder->put_RateControl(1);
	pH264Encoder->put_Bitrate(10000000);
	pH264Encoder->put_MinBitrate(6000000);
	pH264Encoder->put_MaxBitrate(15000000);
	pH264Encoder->put_Usage(0);
	pH264Encoder->put_GOP(TRUE);
	pH264Encoder->put_AutoBitrate(TRUE);

	int idr = 120;
	int p = 1;
	pH264Encoder->put_SliceIntervals(&idr, &p);

	long bitrate;
	pH264Encoder->get_Bitrate(&bitrate);
	std::cout << "Codificador H.264 configurado:" << std::endl;
	std::cout << "  Bitrate: " << (bitrate / 1000000.0) << " Mbps" << std::endl;

	pH264Encoder->Release();
}
```

### Ejemplo en C++ – Streaming en Vivo

```cpp
void ConfigureH264LiveStreaming(IBaseFilter* pVideoEncoder)
{
	IH264Encoder* pH264Encoder = NULL;
	HRESULT hr = pVideoEncoder->QueryInterface(IID_IH264Encoder,
											   (void**)&pH264Encoder);
	if (SUCCEEDED(hr) && pH264Encoder)
	{
		pH264Encoder->put_Profile(77);
		pH264Encoder->put_Level(31);
		pH264Encoder->put_RateControl(0);
		pH264Encoder->put_Bitrate(3500000);
		pH264Encoder->put_Usage(1);
		pH264Encoder->put_GOP(TRUE);
		pH264Encoder->put_AutoBitrate(FALSE);

		int idr = 60;
		int p = 1;
		pH264Encoder->put_SliceIntervals(&idr, &p);

		std::cout << "Streaming H.264 configurado" << std::endl;
		pH264Encoder->Release();
	}
}
```

### Ejemplo en Delphi – Codificación de Alta Calidad

```delphi
uses
  DirectShow9, ActiveX;

procedure ConfigureH264HighQuality(VideoEncoder: IBaseFilter);
var
  H264Encoder: IH264Encoder;
  IDR, P: Integer;
  Bitrate: Integer;
  hr: HRESULT;
begin
  hr := VideoEncoder.QueryInterface(IID_IH264Encoder, H264Encoder);
  if Failed(hr) or (H264Encoder = nil) then
  begin
	WriteLn('Error: El filtro no soporta IH264Encoder');
	Exit;
  end;

  try
	H264Encoder.put_Profile(100);
	H264Encoder.put_Level(41);
	H264Encoder.put_RateControl(1);
	H264Encoder.put_Bitrate(10000000);
	H264Encoder.put_MinBitrate(6000000);
	H264Encoder.put_MaxBitrate(15000000);
	H264Encoder.put_Usage(0);
	H264Encoder.put_GOP(True);
	H264Encoder.put_AutoBitrate(True);

	IDR := 120;
	P := 1;
	H264Encoder.put_SliceIntervals(IDR, P);

	H264Encoder.get_Bitrate(Bitrate);
	WriteLn('Codificador H.264 listo para alta calidad:');
	WriteLn('  Bitrate: ', Bitrate / 1000000:0:1, ' Mbps');
  finally
	H264Encoder := nil;
  end;
end;
```

### Ejemplo en Delphi – Streaming en Vivo

```delphi
procedure ConfigureH264LiveStreaming(VideoEncoder: IBaseFilter);
var
  H264Encoder: IH264Encoder;
  IDR, P: Integer;
begin
  if Succeeded(VideoEncoder.QueryInterface(IID_IH264Encoder, H264Encoder)) then
  begin
	try
	  H264Encoder.put_Profile(77);
	  H264Encoder.put_Level(31);
	  H264Encoder.put_RateControl(0);
	  H264Encoder.put_Bitrate(3500000);
	  H264Encoder.put_Usage(1);
	  H264Encoder.put_GOP(True);
	  H264Encoder.put_AutoBitrate(False);

	  IDR := 60;
	  P := 1;
	  H264Encoder.put_SliceIntervals(IDR, P);

	  WriteLn('Streaming H.264 configurado para 720p @ 3.5 Mbps');
	finally
	  H264Encoder := nil;
	end;
  end;
end;
```

## Mejores Prácticas

### Guías de Selección de Bitrate

| Resolución | CBR (streaming) | VBR objetivo | VBR mínimo-máximo |
|------------|-----------------|--------------|-------------------|
| 360p (SD)  | 0.8 Mbps        | 1 Mbps       | 0.5 - 1.5 Mbps    |
| 480p (SD)  | 1.5 Mbps        | 2 Mbps       | 1 - 3 Mbps        |
| 720p (HD)  | 3 Mbps          | 4 Mbps       | 2.5 - 6 Mbps      |
| 1080p      | 6 Mbps          | 8 Mbps       | 5 - 12 Mbps       |
| 1440p (2K) | 12 Mbps         | 16 Mbps      | 10 - 24 Mbps      |
| 2160p (4K) | 25 Mbps         | 35 Mbps      | 20 - 50 Mbps      |

**Ajustes por tipo de contenido**:
- **Bajo movimiento**: 60-70 % del bitrate recomendado
- **Movimiento medio**: Valor recomendado
- **Alto movimiento**: 120-150 % del bitrate recomendado

### Selección de Perfil

- **Baseline (66)**: Máxima compatibilidad, dispositivos antiguos, codificación en hardware limitado.
- **Main (77)**: Equilibrio entre calidad y compatibilidad, streaming general.
- **High (100)**: Recomendado; mejor compresión para dispositivos modernos y producción.

### Recomendaciones de GOP

- **Streaming**: IDR de 60-120 cuadros (2-4 s). Intervalos cortos = mejor búsqueda, intervalos largos = menor bitrate.
- **Archivos/VOD**: IDR de 240-300 cuadros (8-10 s) para equilibrar tamaño y búsqueda.
- **Baja latencia**: IDR de 30-60 cuadros (1-2 s).
- **Codificación intra (edición)**: `put_GOP(false)`; todos los cuadros son clave; requiere 3-5x bitrate.

### Selección del Modo de Uso

- **Calidad (0)**: Codificación más lenta, ideal para archivos maestros.
- **Equilibrado (1)**: Buena calidad con rendimiento estable; recomendado para streaming en tiempo real.
- **Velocidad (2)**: Prioriza rendimiento, sacrifica calidad; útil en hardware limitado o vigilancia.

## Solución de Problemas

### Baja Calidad de Video

**Síntomas**: Artefactos, bloques, pérdida de detalle.

**Posibles causas**:
1. Bitrate insuficiente para la resolución.
2. Perfil inadecuado.
3. Intervalo IDR demasiado largo.
4. Modo de uso configurado en Velocidad.

**Soluciones**:
- Aumente el bitrate según la tabla recomendada.
- Cambie a High Profile (100).
- Reduzca el intervalo IDR a 120-180 cuadros.
- Use el modo Equilibrado o Calidad.
- En VBR, incremente el bitrate mínimo.

### Codificación Demasiado Lenta

**Síntomas**: Frames perdidos, incapacidad de codificar en tiempo real.

**Soluciones**:
1. Cambie a Baseline (66).
2. Configure `Usage` en Velocidad (2).
3. Reduzca el bitrate.
4. Aumente el intervalo IDR para disminuir procesamiento.
5. Considere codificadores hardware (NVENC, QuickSync).

### Archivos Excesivamente Grandes

**Causas posibles**:
1. Bitrate demasiado alto.
2. Modo CBR conservador.
3. GOP deshabilitado (solo I-frames).
4. Nivel incorrecto.

**Soluciones**:
- Cambie a VBR.
- Habilite GOP (`put_GOP(true)`).
- Ajuste bitrate objetivo y rangos min/máx.
- Use High Profile para mejor compresión.

### Problemas de Compatibilidad en Streaming

**Causas**:
1. Perfil avanzado no soportado.
2. Nivel demasiado alto.
3. Configuración de slices incompatible.

**Soluciones**:
- Use Main (77) o Baseline (66).
- Establezca el nivel en 0 para selección automática.
- Pruebe en los dispositivos de destino.

### Problemas al Buscar en la Línea de Tiempo

**Causa**: Intervalo IDR muy largo.

**Soluciones**:
- Reduzca el intervalo a 60-120 cuadros.
- Para edición, considere codificación intra (`put_GOP(false)`).

---

## Ver También

- [Interfaz del Codificador NVENC](nvenc.md)
- [Referencia de Códecs de Video](../codecs-reference.md)
- [Descripción General del Paquete de Filtros de Codificación](../index.md)
- [Interfaz del Multiplexor MP4](mp4-muxer.md)
